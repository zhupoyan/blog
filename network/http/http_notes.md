# http 小记

<br>

**更新动态：**

> 2018.11.25: 网络专栏-http-http 小记(C)

<br>

**主要参考：**

* 《图解HTTP》上野宣 著, 于均良 译

* [MDN - HTTP](https://developer.mozilla.org/zh-CN/docs/Web/HTTP)

<br>

## 正文

> **背景：**

> 很久没有更新，是因为这段时间本人一直辗转在各个公司的面试中，期间又收割了一大波经验值。

> 由于之前一直没有系统的去学习 http 这一块知识，趁着这躺面试之旅，好好的给自己补了一波 http 鸡汤。先是发现《图解HTTP》这本书很受欢迎，果断下单啃了下来，之后在刷面试题的时候发现有些知识在这本书上没有提及到或是讲解的不够细，又找了些优秀的 blog 补充了知识。最后发现对 http 这一块越来越感兴趣，就一跺脚买了《HTTP权威指南》（ but 到现在还没抽出时间看多少 ）。通过面试题同时也发现，http2.0 似乎已经加入到了面试题的常规队列，就又买了《HTTP/2 基础教程》来啃（ 本章不会谈及 http2.0 ）。

> http 这一块内容可以说是当今前端领域必备的知识，很多面试题要么是直接问 http 的内容，要么是会联系到 http 知识，甚至有些公司由于业务需要，对这一块要求可能特别高。

> 可是我琢磨了半天题目改定什么，如果是叫 http 原理，或是叫 http 解析，之类的，感觉书本讲的比我说的细致多了，我又何必去踩这个坑呢，最后想到 http 小记这个题目还不错。我不会特别详细的展开讲 http，但会结合我的经验和感想挑一些可能是小白最想了解的点来小谈。

<br>

**正题：**

**HTTP** 是 **HyperText Transfer Protocol** 的缩写，译作 **超文本传输协议**。属于**应用层**协议，用于传输超媒体文档（ 如 HTML ）。基于 **浏览器 - 服务器** 的模型，简单说即浏览器发出请求，服务器收到请求后经过处理，返回响应给浏览器。它是 **可扩展的、不带状态的** 协议。

如果是从未接触过HTTP的童鞋，可以通过这个方法最快速直观地感受http：

1. 打开浏览器，打开开发者工具，一般在浏览器的工具菜单里，一般可通过快捷键F12调出
2. 打开开发者工具里的 Network 标签页
3. 访问任意网站，如 https://www.baidu.com/

之后你可以看到 Network 下方的空白区域，会出现一些数据项，每一行数据就代表了一次 http 的请求和响应。随便点击一个，在右侧就会出现一个新窗口，里面就是关于 http 的详细信息，先不一一介绍，等学习了 http 后自然就看得懂。

HTTP是如何运作的，开头提及了它是基于 浏览器 - 服务器 的模型，那么就从这个通信过程出发去了解它。

从浏览器发起请求，和从服务器返回响应，是一个个的 http 的包，不同的协议有不同格式的包， http 的包也有自己的格式，并且请求包跟响应包还不一样。

请求包格式：

```
  GET /a.html HTTP/1.1
  accept: */*
  accept-encoding: gzip, deflate, br
  accept-language: zh-CN,zh;q=0.9
  cache-control: no-cache

  q&cp=0&client=psy-ab&xssi=t
```

解析：

```
  [请求方法](空格)[请求URL](空格)[HTTP协议及版本]
  [请求头key 1]: [请求头value 1]
  ......
  [请求头key n]: [请求头value n]
  (空行)
  [请求实体]
```

响应包格式：

```
  HTTP/1.1 200 OK
  accept: */*
  accept-encoding: gzip, deflate, br
  accept-language: zh-CN,zh;q=0.9
  cache-control: no-cache

  {k: 1, l: "1", q: "cLjvlsk_my9kJz-iZLy43ghcEqA"}
```

解析：

```
  [HTTP协议及版本](空格)[响应状态码](空格)[响应状态信息]
  [响应头key 1]: [响应头value 1]
  ......
  [响应头key n]: [响应头value n]
  (空行)
  [响应实体]
```

（PS: 有的资料里称作这里的包为报文，在我看来，这其实是由于处于不同协议的环境从而产出的不同叫法，实际上都是在抽象概念中，传输过程中的最小单位。）

从包格式上就体现了 http 几个核心知识点：

### 请求方法

请求方法就如同一条指令，请求包需要体现出它的请求指令是什么，服务器端才能做相应处理，返回合适的响应。常见的有以下几种：

* GET: 获取数据。

* POST: 将实体（数据）提交到服务器端，通常会导致服务器端的状态变化或副作用（可简单理解为数据的改变）。

* HEAD: 与 GET 相似，区别在于响应包不含响应体，一般可用于获取某资源前预先获取头部信息。

* PUT: 上传资源。

* DELETE: 删除资源。

* OPTIONS: 获取描述目标资源的选项，一般用于获取目标资源可请求的方法。

### HTTP协议及版本

一般使用的 HTTP 版本为 1.1。尽管HTTP已经有2.0版本，但是由于使用成本较高，技术上更新换代的难点等原因，2.0 版本尚未普及。

### 响应状态码 & 响应状态信息

每个请求对应的响应的状态的体现。状态码一般由三位数字组成，状态信息一般每个状态码对应会有默认的信息。状态码一般按第一位的数字分为这几类：

* 1开头：信息响应类，一般指请求还在处理中的状态。例如：

  * 100 Continue：表明迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。

* 2开头：成功响应类。例如：

  * 200 OK：请求成功。
  * 204 No Content：请求成功，但不返回任何实体内容。
  * 206 Partial Content：表明这是一个部分请求，返回请求头部中 Range 指定的数据。

* 3开头：重定向响应类。例如：

  * 301 Moved Permanently：表明资源被永久的迁移到一个新的位置，一些客户端还会根据状态码，自动将旧有的资源 uri 相关的信息修改成从服务端返回的新的资源 uri ，之后再次请求这个资源将使用新的 uri。
  * 302 Found：表明资源从一个临时性的 uri 被返回，之后再次请求这个资源依然使用旧的 uri。
  * 303 See Other：大致同 302，不同的是 303 会要求客户端使用 GET 方法请求资源。
  * 304 Not Modified：这是一个与重定向没有多大关系的状态，它与缓存有关。当资源命中了请求包头部中的缓存相关的信息时返回，这时客户端将使用缓存资源。

* 4开头：客户端响应类。例如：

  * 400 Bad Request：语义错误或参数错误。
  * 401 Unauthorized：验证信息未通过。
  * 403 Forbidden：拒绝访问。
  * 404 Not Found：未找到对应资源。
  * 405 Method Not Allowed：当前请求方法不被允许。

* 5开头：服务端响应类。例如：

  * 500 Internal Server Error：服务器错误。
  * 502 Bad Gateway：网关错误。
  * 503 Service Unavailable：服务器不能正常处理请求。原因一般是由于服务器正在维护，这时候服务器返回的响应包头部应该要有 Retry-After ，让客户端知晓估计多久时间后可以再次发起请求。
  * 504 Gateway Timeout：服务器超时。

### 请求/响应 头

请求/响应 头是 HTTP 很重要的一个点，里面包含了大部分的 http 包信息，一般分为以下几类：

* 请求头部信息：关于请求包的信息。

* 响应头部信息：关于响应包的信息。

* 通用头部信息：请求包和响应包通用的信息。

* 实体头部信息：关于实体的信息。

### Cookie

由于 HTTP 本身是无状态的，Cookies 的出现可以说解决了这一问题。简单来说，它根据服务器端发送给客户端的一小段数据生成。

服务端返回的响应包头部中如果有 Set-Cookie ，客户端将根据对应字段信息存储 cookies 数据。当客户端再次向同一个 uri 发起请求时，一般会自动将 cookies 数据附带到请求头部字段 Cookie，服务端获取到 Cookies 数据后可作相应处理。

Cookie 一般可分为 **会话期Cookie** 和 **持久性Cookie**

* 会话期Cookie
  * 不需要指定 Expires 或 Max-Age，浏览器关闭后会被自动删除。
  * 有些浏览器具有会话恢复功能，即使关闭了浏览器，cookie 也不会被自动删除。

* 持久性Cookie
  * 要指定 Expires 或 Max-Age，且指定的时间只与客户端有关。

```
  Set-Cookie: <cookie-name>=<cookie-value>[; Expires=<date>][; Max-Age=<non-zero-digit>][; Domain=<domain-value>][; Path=<path-value>][; Secure][; HttpOnly][; SameSite=<value>]
```

按照 Set-Cookie 的格式介绍 Cookie 的几个点：

* Expires: cookie 的最长有效时间，形式为符合 HTTP-date 规范的时间戳。

* Max-Age: 在 cookie 失效之前需要经过的秒数。秒数为 0 或 -1 将会使 cookie 直接过期。若 Expires 和 Max-Age 均存在，Max-Age 优先级更高。

* Domain: 指定 cookie 可以发送的主机名。如果没有指定，则为当前文档访问地址中的主机部分（不包含子域名）。如果指定了域名，各个子域名也将包含在内。

* Path: 指定一个 URL ，这个 URL 必须出现在将要请求的资源的 URL 中，才可以发送 Cookie 首部。如果 path=/docs，那么 "/docs", "/docs/Web/" 或者 "/docs/Web/HTTP" 都满足匹配的条件。

* Secure: 只有在请求使用 SSL 和 HTTPS 协议的时候，才会被发送到服务器。

* HttpOnly: 不能使用 JavaScript 通过 Document.cookie 、XMLHttpRequest 和 Request APIs 访问 Cookie，以防范跨站脚本攻击（XSS）。

* SameSite: 使得 Cookie 不随着跨域请求一起发送，可以在一定程度上防范跨站请求伪造攻击（CSRF）。

**结尾：**
